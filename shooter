<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple 3D Shooter â€” Play as the character</title>
<style>
  html,body { height:100%; margin:0; overflow:hidden; font-family:Arial,Helvetica,sans-serif; }
  #hud {
    position: absolute; top: 10px; left: 10px; color: #fff; z-index: 10;
    background: rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px;
  }
  #instructions {
    position: absolute; bottom: 10px; left: 10px; color:#fff; z-index:10;
    background: rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px;
  }
  canvas { display:block; }
  #crosshair {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:12px; height:12px; pointer-events:none; z-index:9;
  }
  #crosshair:before, #crosshair:after {
    content:""; position:absolute; left:50%; top:50%; width:2px; height:12px; background:#fff; transform:translate(-50%,-50%);
  }
  #crosshair:after { transform: translate(-50%,-50%) rotate(90deg); }
</style>
</head>
<body>
<div id="hud">
  <div>Score: <span id="score">0</span></div>
  <div>Enemies alive: <span id="alive">0</span></div>
  <div>Health: <span id="health">100</span></div>
</div>
<div id="instructions">Click to lock pointer. Move: WASD. Shoot: Left click.</div>
<div id="crosshair"></div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';
import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/controls/PointerLockControls.js';

let scene, camera, renderer, controls;
let playerSprite;
const projectiles = [];
const enemies = [];
let score = 0;
let health = 100;

const scoreEl = document.getElementById('score');
const aliveEl = document.getElementById('alive');
const healthEl = document.getElementById('health');
const instructions = document.getElementById('instructions');

// Basic init
scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // sky-like

camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 5); // eye height

renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
hemi.position.set(0, 20, 0);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(-3, 10, -10);
scene.add(dir);

// Ground
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshPhongMaterial({color:0x6aa84f}));
ground.rotation.x = -Math.PI/2;
ground.position.y = 0;
scene.add(ground);

// Simple arena boundary markers
const borderGeo = new THREE.BoxGeometry(200, 1, 1);
const borderMat = new THREE.MeshBasicMaterial({color:0x333});
const b1 = new THREE.Mesh(borderGeo, borderMat); b1.position.set(0,0.5,-100); scene.add(b1);
const b2 = b1.clone(); b2.position.set(0,0.5,100); scene.add(b2);
const b3 = new THREE.Mesh(new THREE.BoxGeometry(1,1,200), borderMat); b3.position.set(-100,0.5,0); scene.add(b3);
const b4 = b3.clone(); b4.position.set(100,0.5,0); scene.add(b4);

// Controls
controls = new PointerLockControls(camera, renderer.domElement);
document.body.addEventListener('click', () => {
  controls.lock();
});
controls.addEventListener('lock', () => instructions.style.display = 'none');
controls.addEventListener('unlock', () => instructions.style.display = 'block');
scene.add(controls.getObject());

// Player visible avatar (billboard) using user-provided image
const loader = new THREE.TextureLoader();
// The file name below should match the image you saved alongside this HTML.
// If your image filename is different, change this string to match it.
const playerImagePath = 'player.png';

loader.load(playerImagePath, (tex) => {
  const mat = new THREE.SpriteMaterial({ map: tex, sizeAttenuation: false });
  playerSprite = new THREE.Sprite(mat);
  playerSprite.scale.set(1.2, 1.6, 1); // look tall
  playerSprite.position.set(0, 0.9, 0); // attached to player
  controls.getObject().add(playerSprite);
}, undefined, (err) => {
  console.warn('Could not load player image at', playerImagePath, err);
});

// Simple function to create text label textures (for enemy names)
function makeLabelTexture(text) {
  const size = 256;
  const canvas = document.createElement('canvas');
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fffc';
  ctx.fillRect(0,0,size,size);
  ctx.font = 'bold 36px Arial';
  ctx.fillStyle = 'black';
  ctx.textAlign = 'center';
  ctx.fillText(text, size/2, size/2 + 12);
  return new THREE.CanvasTexture(canvas);
}

// Enemy creation
function spawnEnemy(name, pos) {
  const geo = new THREE.BoxGeometry(1, 1.8, 0.8);
  const mat = new THREE.MeshPhongMaterial({ color: 0xff6666 });
  const m = new THREE.Mesh(geo, mat);
  m.position.copy(pos);
  m.userData = { name, hp: 3 };
  // add a label above
  const labelMat = new THREE.SpriteMaterial({ map: makeLabelTexture(name) });
  const label = new THREE.Sprite(labelMat);
  label.scale.set(1.8, 0.5, 1);
  label.position.set(0, 1.4, 0);
  m.add(label);
  scene.add(m);
  enemies.push(m);
  updateHUD();
  return m;
}

// Spawn a few enemies (Rodrick and Greg variants)
spawnEnemy('Rodrick', new THREE.Vector3(0, 0.9, -20));
spawnEnemy('Greg', new THREE.Vector3(6, 0.9, -18));
spawnEnemy('Rodrick', new THREE.Vector3(-7, 0.9, -22));

// Movement state
const move = { forward:false, back:false, left:false, right:false };
let velocity = new THREE.Vector3();

document.addEventListener('keydown', (e) => {
  if (e.code === 'KeyW') move.forward = true;
  if (e.code === 'KeyS') move.back = true;
  if (e.code === 'KeyA') move.left = true;
  if (e.code === 'KeyD') move.right = true;
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'KeyW') move.forward = false;
  if (e.code === 'KeyS') move.back = false;
  if (e.code === 'KeyA') move.left = false;
  if (e.code === 'KeyD') move.right = false;
});

// Shooting
let canShoot = true;
const shootCooldown = 160; // ms
window.addEventListener('mousedown', (e) => {
  if (e.button === 0 && controls.isLocked) shoot();
});

function shoot() {
  if (!canShoot) return;
  canShoot = false;
  setTimeout(()=> canShoot = true, shootCooldown);
  // projectile origin slightly in front of camera
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  const origin = camera.position.clone().add(dir.clone().multiplyScalar(1.0));
  const speed = 60;
  const projGeo = new THREE.SphereGeometry(0.12, 8,8);
  const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const sphere = new THREE.Mesh(projGeo, mat);
  sphere.position.copy(origin);
  sphere.userData = { vel: dir.clone().multiplyScalar(speed), life: 2.5, owner: 'player' };
  scene.add(sphere);
  projectiles.push(sphere);
  // small muzzle flash effect
  const flash = new THREE.PointLight(0xffdd88, 1, 5);
  flash.position.copy(origin);
  scene.add(flash);
  setTimeout(()=> scene.remove(flash), 60);
}

// Simple collision detection and projectile update
function updateProjectiles(dt) {
  for (let i = projectiles.length-1; i>=0; i--) {
    const p = projectiles[i];
    p.position.addScaledVector(p.userData.vel, dt);
    p.userData.life -= dt;
    // check collision with enemies
    const bbox = new THREE.Box3();
    let removed = false;
    for (let j = enemies.length-1; j>=0; j--) {
      const e = enemies[j];
      bbox.setFromObject(e);
      if (bbox.containsPoint(p.position)) {
        // hit!
        e.userData.hp -= 1;
        // flash enemy
        e.material.color.setHex(0xffff66);
        setTimeout(()=> e.material.color.setHex(0xff6666), 120);
        if (e.userData.hp <= 0) {
          // remove enemy
          scene.remove(e);
          enemies.splice(j,1);
          score += 100;
          updateHUD();
          // respawn it after a few seconds with new hp
          setTimeout(()=> {
            const spawnX = (Math.random()-0.5)*30;
            const spawnZ = -15 - Math.random()*25;
            const name = Math.random()<0.5 ? 'Rodrick':'Greg';
            const newE = spawnEnemy(name, new THREE.Vector3(spawnX,0.9,spawnZ));
            newE.userData.hp = 3;
          }, 2500 + Math.random()*2000);
        }
        // remove projectile
        scene.remove(p);
        projectiles.splice(i,1);
        removed = true;
        break;
      }
    }
    if (removed) continue;
    // remove if life expired or too far
    if (p.userData.life <= 0 || p.position.length() > 500) {
      scene.remove(p);
      projectiles.splice(i,1);
    }
  }
}

// Enemy AI: simple look toward player and occasionally shoot back
const enemyProjectiles = [];
function updateEnemies(dt) {
  enemies.forEach(e => {
    // look toward player
    const v = controls.getObject().position.clone().sub(e.position);
    const angle = Math.atan2(v.x, v.z);
    e.rotation.y = angle;
    // move a tiny bit toward player if far
    const dist = v.length();
    if (dist > 6) {
      const step = Math.min(dt * 1.2, 0.02);
      e.position.add(v.normalize().multiplyScalar(step));
    } else {
      // attack chance
      if (Math.random() < dt * 0.4) {
        // create enemy projectile
        const dir = controls.getObject().position.clone().sub(e.position).normalize();
        const projGeo = new THREE.SphereGeometry(0.12,8,8);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff3333 });
        const sphere = new THREE.Mesh(projGeo, mat);
        sphere.position.copy(e.position).add(new THREE.Vector3(0,1.0,0));
        sphere.userData = { vel: dir.multiplyScalar(18), life: 4, owner: 'enemy' };
        scene.add(sphere);
        enemyProjectiles.push(sphere);
      }
    }
  });

  // enemy projectile updates + collisions with player
  for (let i = enemyProjectiles.length-1; i>=0; i--) {
    const p = enemyProjectiles[i];
    p.position.addScaledVector(p.userData.vel, dt);
    p.userData.life -= dt;
    const playerPos = controls.getObject().position.clone();
    if (p.position.distanceTo(playerPos) < 0.6) {
      // hit player
      health -= 8;
      health = Math.max(0, health);
      healthEl.textContent = health;
      scene.remove(p);
      enemyProjectiles.splice(i,1);
      if (health <= 0) {
        // simple death handling: reset health and score penalty
        health = 100;
        score = Math.max(0, score - 200);
        scoreEl.textContent = score;
      }
      continue;
    }
    if (p.userData.life <= 0 || p.position.length() > 500) {
      scene.remove(p);
      enemyProjectiles.splice(i,1);
    }
  }
}

// HUD update
function updateHUD() {
  scoreEl.textContent = score;
  aliveEl.textContent = enemies.length;
  healthEl.textContent = health;
}

// Main loop
let prevTime = performance.now();
function animate() {
  requestAnimationFrame(animate);
  const time = performance.now();
  const dt = (time - prevTime) / 1000;
  prevTime = time;

  // movement
  const speed = 6;
  velocity.x -= velocity.x * 10.0 * dt;
  velocity.z -= velocity.z * 10.0 * dt;
  if (move.forward) velocity.z -= speed * dt;
  if (move.back)    velocity.z += speed * dt;
  if (move.left)    velocity.x -= speed * dt;
  if (move.right)   velocity.x += speed * dt;

  controls.moveRight(-velocity.x);
  controls.moveForward(-velocity.z);

  // simple boundary clamp
  const pos = controls.getObject().position;
  pos.x = THREE.MathUtils.clamp(pos.x, -95, 95);
  pos.z = THREE.MathUtils.clamp(pos.z, -95, 95);
  pos.y = 1.6; // keep eye height consistent

  // update projectiles and enemies
  updateProjectiles(dt);
  updateEnemies(dt);

  // camera follows small bobbing when moving (cosmetic)
  const speedFactor = Math.min(1, Math.abs(velocity.x) + Math.abs(velocity.z));
  camera.position.y = 1.6 + Math.sin(time * 0.002 * (1 + speedFactor*3)) * 0.02 * speedFactor;

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

animate();

</script>
</body>
</html>
